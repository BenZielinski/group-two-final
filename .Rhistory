#################
summer_break <- as.Date("2018-6-9")
today <- Sys.Date()
days_to_break <- summer_break - today
print(days_to_break)
# Builds an introduction that gives number of days until next birthday
# Inputs: name, age, date object
# Output: string
make_birthday_intro <- function(name, age, birthday_date) {
difference <- birthday_date - Sys.Date()
if (difference < 0) {
difference <- difference + 365
}
intro <- make_introduction(name, age)
new_age <- age + 1
birthday_intro <- paste(intro, "In", difference, "days I'll be", new_age)
birthday_intro
}
my_bday_intro <- make_birthday_intro(my_name, my_age, as.Date("2018-03-30"))
print(my_bday_intro)
#################
#### PART 1 #####
#################
library("stringr")
my_age <- 20
my_name <- "Benjamin Zielinski"
# Writes a brief introduction giving a person's name
# Inputs: a name and an age
# Output: a character string
make_introduction <- function(name, age) {
paste("Hello my name is", name, "and I'm", age, "years old.")
}
my_intro <- make_introduction(my_name, my_age)
print(my_intro)
casual_intro <- sub("Hello my name is", "Hey, I'm", my_intro)
print(casual_intro)
capital_intro <- str_to_title(my_intro)
print(capital_intro)
intro_e_count <- str_count(my_intro, "e")
print(intro_e_count)
#################
#### PART 2 #####
#################
books <- c("Hunger Games", "Eragon", "Pendragon", "A Song of Ice and Fire", "Paper Towns", "Maze Runner")
print(books)
top_three_books <- books[1:3]
print(top_three_books)
book_reviews <- paste(books, "is a great read!")
print(book_reviews)
# Removes a book that should no longer be on a list of books
# Inputs: a list of books and an index for which book should be removed
# Output: a list of books that doesn't contain the indicated book
remove_book <- function(book_list,index) {
index <- -1 * index
book_list[index]
}
books_without_four <- remove_book(books, 4)
print(books_without_four)
long_titles <- books[nchar(books) > 15]
print(long_titles)
#################
#### PART 3 #####
#################
numbers <- 1:201
squared_numbers <- numbers^2
squared_mean <- mean(squared_numbers)
print(squared_mean)
# Uses the length() function and divides by 2 to find the middle index, i.e. median
squared_median <- squared_numbers[length(squared_numbers) / 2]
print(squared_median)
squares <- numbers[sqrt(numbers) == round(sqrt(numbers))]
print(squares)
#################
#### PART 4 #####
#################
summer_break <- as.Date("2018-6-9")
today <- Sys.Date()
days_to_break <- summer_break - today
print(days_to_break)
# Builds an introduction that gives number of days until next birthday
# Inputs: name, age, date object
# Output: string
make_birthday_intro <- function(name, age, birthday_date) {
difference <- birthday_date - Sys.Date()
if (difference < 0) {
difference <- difference + 365
}
intro <- make_introduction(name, age)
new_age <- age + 1
birthday_intro <- paste(intro, "In", difference, "days I'll be", new_age)
birthday_intro
}
my_bday_intro <- make_birthday_intro(my_name, my_age, as.Date("2018-03-30"))
print(my_bday_intro)
iris_df <- data.frame(iris)
View(iris_df)
# Select only rows of Virginica flowers
iris_df[iris_df$Species == virginica]
# Select only rows of Virginica flowers
iris_df[iris_df$Species == "virginica"]
iris_df <- data.frame(iris)
# Select only rows of Virginica flowers
iris_df[iris_df$Species == "virginica"]
# Select only rows of Virginica flowers
iris_df[iris_df$Species == "virginica", ]
# Select only the sepal legnth of the Virginica flowers
iris_df[iris_df$Species == "virginica", "Sepal.Length"]
# Select rows where Petal.Length > 4.0
iris_df[iris_df$Petal.Length > 4.0, ]
# Add a column to the dataframe indicating whether Petal.Length > 4.0
iris_df$long_petals <- iris_df$Petal.Length > 4.0
View(iris_df)
# Find the species type of the flower that has the longest Sepal length
iris_df[iris_df$Sepal.Length == max(iris_df$Sepal.Length), "Species"]
View(iris_df)
# Select rows where species type is 'setosa' and Sepal.Width > 3.0
iris_df[iris_df$Species == "setosa" && iris_df$Sepal.Width > 3.0, ]
# Select rows where species type is 'setosa' and Sepal.Width > 3.0
iris_df[iris_df$Species == "setosa" && iris_df$Sepal.Width > 3.0, ]
# Find the species type of the flower that has the longest Sepal length
iris_df[iris_df$Sepal.Length == max(iris_df$Sepal.Length), "Species"]
# Select rows where species type is 'setosa' and Sepal.Width > 3.0
iris_df[iris_df$Species == "setosa" & iris_df$Sepal.Width > 3.0, ]
install.packages("nycflights13")
library(nycflights13)
library(dplyr)
# The data frame `flights` should now be accessible to you.
# Use functions to inspect it: how many rows and columns does it have?
# What are the names of the columns?
# Use `??flights` to search for documentation on the data set (for what the
# columns represent)
colnames(flights)
??flights
# Use `dplyr` to give the data frame a new column that is the amount of time
# gained or lost while flying (that is: how much of the delay arriving occured
# during flight, as opposed to before departing).
flights <- flights %>%
mutate(gain_in_air = arr_delay - dep_delay)
View(flights)
flights <- flights %>%
arrange(gain_in_air)
View(flights)
flights <- flights %>%
arrange(-gain_in_air)
View(flights)
?hist
# Make a histogram of the amount of time gained using the `hist()` function
hist(flights$gain_in_air)
# On average, did flights gain or lose time?
# Note: use the `na.rm = TRUE` argument to remove NA values from your aggregation
flights %>%
summarise(avg = mean(gain_in_air, na.rm = TRUE))
# Create a data.frame of flights headed to SeaTac ('SEA'), only including the
# origin, destination, and the "gain_in_air" column you just created
sea <- flights %>%
filter(dest == "SEA") %>%
select(origin, dest, gain_in_air)
View(sea)
# Create a data.frame of flights headed to SeaTac ('SEA'), only including the
# origin, destination, and the "gain_in_air" column you just created
sea <- flights %>%
filter(dest == "SEA") %>%
select(origin, dest, gain_in_air) %>%
summarise(avg = mean(gain_in_air, na.rm = TRUE))
sea
# Consider flights from JFK to SEA. What was the average, min, and max air time
# of those flights? Bonus: use pipes to answer this question in one statement
# (without showing any other data)!
flights %>%
filter(origin == "JFK", dest == "SEA") %>%
summarize(
average = mean(air_time, na.rm = TRUE),
min = min(air_time, na.rm = TRUE),
max = max(air_time, na.rm = TRUE)
)
library(nycflights13)
library(dplyr)
# What was the average departure delay in each month?
# Save this as a data frame `dep_delay_by_month`
# Hint: you'll have to perform a grouping operation then summarizing your data
dep_delay_by_month <- flights %>%
group_by(month) %>%
summarize(avg = mean(dep_delay, na.rm = TRUE))
dep_delay_by_month
# What was the average departure delay in each month?
# Save this as a data frame `dep_delay_by_month`
# Hint: you'll have to perform a grouping operation then summarizing your data
dep_delay_by_month <- flights %>%
group_by(month) %>%
summarize(month = month, avg = mean(dep_delay, na.rm = TRUE))
# Which month had the greatest average departure delay?
dep_delay_by_month %>%
filter(avg == max(avg))
# If your above data frame contains just two columns (e.g., "month", and "delay" in that order), you can create
# a scatterplot by passing that data frame to the 'plot()' function
plot(dep_delay_by_month)
flights %>%
group_by(dest) %>%
summarize(avg_arr_delay = mean(arr_delay)) %>%
arrange(avg_arr_delay) %>%
head()
# You can look up these airports in the `airports` data frame!
View(airports)
# To which destinations were the average arrival delays the highest?
# Hint: you'll have to perform a grouping operation then summarize your data
# You can use the `head()` function to view just the first few rows
flights %>%
group_by(dest) %>%
summarize(avg_arr_delay = mean(arr_delay, na.rm = TRUE)) %>%
arrange(avg_arr_delay) %>%
head()
install.packages("ggplot2")
library(ggplot2)
library(dplyr)
?diamonds
library(ggplot2)
library(dplyr)
# For this exercise you'll be working with the `diamonds` data set included in
# the ggplot2 library
# Use `?diamonds` to get more information about this data set (including the
# column descriptions. Also check the _column names_ and the _number of rows_
# in the data set
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
diamonds_sample <- sample_n(diamonds, 1000)
nrow(diamonds_sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = diamonds_sample)
# Draw a scatter plot (with point geometry) with for the `diamonds_sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price))
# Draw the same plot as above, but color each of the points based on their
# clarity.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this
# may take a few seconds to generate.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw a scatter plot for `diamonds_sample` of `price` by `carat`, where each
# point has an aesthetic _shape_ based on the diamond's `cut`.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, shape = cut))
# Draw a scatter plot for `diamonds_sample` of *`cut`* by `carat`, where each
# point has an aesthetic _size_ based on the diamond's *`price`*
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, size = price))
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, size = price))
# Try coloring the above plot based on the diamond's price!
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, size = price, color = price))
# Draw a line plot (with line geometry) for `diamonds_sample`. The x-position
# should be mapped to carat, y-position to price, and color to cut.
ggplot(data = diamonds_sample) +
geom_line(mapping = aes(x = carat, y = price, color = cut))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamonds_sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a plot with bar geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis
ggplot(data = diamonds_sample) +
geom_bar(mapping = aes(x = cut))
# Add an aesthetic property that will _fill_ each bar geometry based on the
# `clarity` of the diamonds.
# What kind of chart do you get?
ggplot(data = diamonds_sample) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = cut))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = carat, y = prices))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = carat, y = price))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = price))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = price, fill = clarity))
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = depth))
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = depth, fill = clarity))
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = diamonds) +
geom_histogram(mapping = aes(x = depth, fill = clarity))
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = depth, fill = clarity))
diamonds_sample <- sample_n(diamonds, 1000)
nrow(diamonds_sample)
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = depth, fill = clarity))
# Install and load the `ggplot2` package
#install.packages('ggplot2')
library(ggplot2)
# Draw a bar chart of the diamonds data, organized by cut
# Each bar's height is based on the "count" (number) of diamonds with that cut
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price))
# Exercise 1: ggplot2 basics
# Install and load the `ggplot2` package
# You will also want to load `dplyr`
library(ggplot2)
library(dplyr)
# For this exercise you'll be working with the `diamonds` data set included in
# the ggplot2 library
# Use `?diamonds` to get more information about this data set (including the
# column descriptions. Also check the _column names_ and the _number of rows_
# in the data set
# This data set has A LOT of rows. To make things a bit more readable,
# use dplyr's `sample_n()` function to get a random 1000 rows from the data set
# Store this sample in a variable `diamonds_sample`
diamonds_sample <- sample_n(diamonds, 1000)
nrow(diamonds_sample)
# Start by making a new `ggplot` with the `diamonds_sample` as the data (no
# geometry yet)
# What do you see? (What did you expect?)
ggplot(data = diamonds_sample)
# Draw a scatter plot (with point geometry) with for the `diamonds_sample` set,
# with the `carat` mapped to the x-position and `price` mapped to the y-position.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price))
# Draw the same plot as above, but color each of the points based on their
# clarity.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw the same plot as above, but for the entire `diamonds` data set. Note this
# may take a few seconds to generate.
ggplot(data = diamonds) +
geom_point(mapping = aes(x = carat, y = price, color = clarity))
# Draw another scatter plot for `diamonds_sample` of price (y) by carat (x),
# but with all of the dots colored "blue".
# Hint: you'll need to set the color channel, not map a value to it!
# Draw a scatter plot for `diamonds_sample` of `price` by `carat`, where each
# point has an aesthetic _shape_ based on the diamond's `cut`.
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, shape = cut))
# Draw a scatter plot for `diamonds_sample` of *`cut`* by `carat`, where each
# point has an aesthetic _size_ based on the diamond's *`price`*
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, size = price))
# Try coloring the above plot based on the diamond's price!
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, size = price, color = price))
# Draw a line plot (with line geometry) for `diamonds_sample`. The x-position
# should be mapped to carat, y-position to price, and color to cut.
ggplot(data = diamonds_sample) +
geom_line(mapping = aes(x = carat, y = price, color = cut))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamonds_sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a plot with bar geometry (a bar chart), mapping the diamond's `cut` to
# the x-axis
ggplot(data = diamonds_sample) +
geom_bar(mapping = aes(x = cut))
# Add an aesthetic property that will _fill_ each bar geometry based on the
# `clarity` of the diamonds.
# What kind of chart do you get?
ggplot(data = diamonds_sample) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw a histogram (using histogram geometry) of diamond prices.
# Try mapping each bar based on clarity as well!
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = price, fill = clarity))
# (For a more traditional "bell-curve", make a histogram of diamond `depth`)
ggplot(data = diamonds_sample) +
geom_histogram(mapping = aes(x = depth, fill = clarity))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price))
# That's kind of messy. Try using `smooth` geometry instead.
ggplot(data = diamonds_sample) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price)) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a plot of the `diamonds_sample` data (price by carat), with both points
# for each diamond AND smoothed lines for each cut (hint: in a separate color)
# Give the points an `alpha` (transparency) of 0.3 to make the plot look nicer
ggplot(data = diamonds_sample) +
geom_point(mapping = aes(x = carat, y = price, alpha = 0.3)) +
geom_smooth(mapping = aes(x = carat, y = price, color = cut))
# Draw a bar chart of the diamonds data, organized by cut
# Each bar's height is based on the "count" (number) of diamonds with that cut
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut))
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut)) +
stat_count()
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut)) +
stat_count(x)
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, stat_count(x)))
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut), stat_count(x))
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut), stat = stat_count(x))
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut), stat = stat_count())
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut), stat = count)
# Use the `stat_count` to apply the statistical transformation "count" to the
# diamonds by cut. You do not need a separate geometry layer!
ggplot(data = diamonds) +
stat_count(mapping = aes(x = cut))
# Use the `stat_summary` function to draw a chart with a summary layer.
# Map the x-position to diamond `cut`, and the y-position to diamond `depth`
# Bonus: use `min` as the function ymin, `max` as the function ymax, and `median`
# as the function y
ggplot(data = diamonds) +
stat_summary(mapping = aes(x = cut, y = depth))
# Draw a bar chart of diamonds organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw a bar chart of diamonds organized by cut, with each bar filled by clarity.
# You should see a _stacked_ bar chart.
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
# Draw the same chart again, but with each element positioned to "fill" the y axis
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity))
# Draw the same chart again, but with each element positioned to "fill" the y axis
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
# Draw the same chart again, but with each element positioned to "dodge" each other
ggplot(data = diamonds) +
geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
# Draw a plot with point geometry with the x-position mapped to `cut` and the
# y-position mapped to `clarity`
# This creates a "grid" grouping the points
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity))
# Use the "jitter" position adjustment to keep the points from all overlapping!
# (This works a little better with a sample of diamond data, such as from the
# previous exercise).
ggplot(data = diamonds) +
geom_point(mapping = aes(x = cut, y = clarity), position = "jitter")
# Draw a "boxplot" (with `geom_boxplot`) for the diamond's price (y) by color (x)
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price))
# This has a lot of outliers, making it harder to read. To fix this, draw the
# same plot but with a _logarithmic_ scale for the y axis.
ggplot(data = diamonds) +
geom_boxplot(mapping = aes(x = color, y = price)) +
scale_y_log10()
install.packages("shiny")
library(shiny)
runApp('C:/Users/Ben/Desktop/shiny-demo')
runApp('C:/Users/Ben/Desktop/shiny-demo')
install.packages("rsconnect")
rsconnect::setAccountInfo(name='benzielinski', token='47255BDD19BF5F4FDBA40DD453D20374', secret='bfhXPObZ8wOwsAeORx3xsRCAwZxfFMf53P544sq4')
runApp('C:/Users/Ben/Desktop/shiny-demo')
setwd("~/College/2017-2018/Spring Quarter/Info 201/a8-data-app-BenZielinski")
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp('~/College/2017-2018/Spring Quarter/Info 201/group-two-final')
runApp('~/College/2017-2018/Spring Quarter/Info 201/group-two-final')
runApp('~/College/2017-2018/Spring Quarter/Info 201/group-two-final')
runApp('~/College/2017-2018/Spring Quarter/Info 201/group-two-final')
runApp('~/College/2017-2018/Spring Quarter/Info 201/group-two-final')
weather_data <- read.csv("data/weather.csv", stringsAsFactors = FALSE)
setwd("~/College/2017-2018/Spring Quarter/Info 201/group-two-final")
weather_data <- read.csv("data/weather.csv", stringsAsFactors = FALSE)
weather_data[1, 1]
typeof(weather_data[1,1])
as.Date(weather_data[1,1])
as.Date(weather_data[1,1], format = "%m/%d/%Y")
